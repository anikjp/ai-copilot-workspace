"""
Working version of main_v2.py with Discovery Endpoints

Features:
- AG-UI Protocol compliant agent system
- Discovery endpoints for agent metadata
- Centralized agent registry
- Real-time streaming with event-driven architecture
- Comprehensive logging and tracing
"""

import os
import logging
from typing import List

import uvicorn
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException, Form
from fastapi.middleware.cors import CORSMiddleware

# Import the base agent system
from shared.agent_base import agent_registry, AgentConfig, AgentType, get_agent_route, get_agent_id_from_route
from shared.rate_limiter import rate_limiter, RateLimitConfig, RateLimitType
# OAuth functionality removed - using Clerk authentication only

# Import agent workflows
from agents.stock_agent.agent import stock_analysis_workflow
from agents.ringi_agent import ringi_workflow
from agents.bpp_agent import bpp_assistant_workflow
from agents.generic_agent import generic_agent_workflow

# Import agent handlers
from agents.stock_agent.handler import StockAnalysisAgentHandler, create_stock_agent_config
from agents.ringi_agent.handler import RingiAgentHandler, create_ringi_agent_config
from agents.generic_agent.handler import GenericAgentHandler, create_generic_agent_config

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("agno_agents_v2.log"),
    ],
)
logger = logging.getLogger(__name__)


class Config:
    """Application configuration"""
    PORT: int = int(os.getenv("PORT", "8000"))
    HOST: str = os.getenv("HOST", "0.0.0.0")
    DEBUG: bool = os.getenv("DEBUG", "false").lower() == "true"
    ALLOWED_ORIGINS: List[str] = [
        "http://localhost:3000",
        "http://localhost:3001",
        "http://127.0.0.1:3000",
        "http://127.0.0.1:3001",
    ]

config = Config()

# Initialize FastAPI application
app = FastAPI(
    title="Agno Agents API V2",
    description="AI Agents with unified base system - Simplified and Scalable",
    version="2.0.0",
    docs_url="/docs" if config.DEBUG else None,
    redoc_url="/redoc" if config.DEBUG else None,
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=config.ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"],
)


# ============================================================================
# HEALTH CHECK ENDPOINTS
# ============================================================================

@app.get("/health")
async def system_health():
    """
    Get overall system health status.
    
    Returns comprehensive health information including all agents,
    dependencies, and system metrics.
    """
    try:
        health_data = agent_registry.get_system_health()
        
        # Add system-level information
        health_data.update({
            "service": "Agno Agents API",
            "version": "2.1.0",
            "environment": "development" if config.DEBUG else "production",
            "protocol": "AG-UI",
            "endpoints": {
                "discovery": "/.well-known/agents",
                "agent_metadata": "/.well-known/{agentId}/agent.json",
                "health": "/health",
                "agent_health": "/agents/{agentId}/health"
            }
        })
        
        # Determine HTTP status code based on system health
        status_code = 200
        if health_data["system_status"] == "degraded":
            status_code = 207  # Multi-Status
        elif health_data["system_status"] == "unhealthy":
            status_code = 503  # Service Unavailable
        
        return health_data
        
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        return {
            "system_status": "unhealthy",
            "error": str(e),
            "timestamp": agent_registry._get_current_timestamp(),
            "service": "Agno Agents API",
            "version": "2.1.0"
        }

@app.get("/agents/{agent_id}/health")
async def agent_health(agent_id: str):
    """
    Get health status for a specific agent.
    
    Returns detailed health information for the specified agent including
    performance metrics, dependencies, and recent errors.
    """
    try:
        # Get agent from registry
        agent_route = get_agent_route(agent_id)
        agent = agent_registry.get_agent(agent_route)
        if not agent:
            raise HTTPException(status_code=404, detail="Agent not found")
        
        health_data = agent.get_health_status()
        
        # Add agent-specific endpoints
        health_data["endpoints"] = {
            "run": agent_route,
            "stream": f"{agent_route}/stream",
            "health": f"/agents/{agent_id}/health",
            "metadata": f"/.well-known/{agent_id}/agent.json"
        }
        
        # Determine HTTP status code based on agent health
        status_code = 200
        if health_data["status"] == "unhealthy":
            status_code = 503  # Service Unavailable
        elif health_data.get("dependencies", {}).get("overall", {}).get("status") == "degraded":
            status_code = 207  # Multi-Status
        
        return health_data
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Agent health check failed for {agent_id}: {e}")
        return {
            "agent_id": agent_id,
            "status": "unhealthy",
            "error": str(e),
            "timestamp": agent_registry._get_current_timestamp()
        }

@app.get("/health/ready")
async def readiness_check():
    """
    Kubernetes readiness probe endpoint.
    
    Returns 200 if the system is ready to accept traffic,
    503 if not ready.
    """
    try:
        health_data = agent_registry.get_system_health()
        
        # System is ready if at least one agent is healthy
        is_ready = health_data["healthy_agents"] > 0
        
        if is_ready:
            return {
                "status": "ready",
                "healthy_agents": health_data["healthy_agents"],
                "total_agents": health_data["total_agents"],
                "timestamp": health_data["timestamp"]
            }
        else:
            return {
                "status": "not_ready",
                "reason": "No healthy agents available",
                "timestamp": health_data["timestamp"]
            }
            
    except Exception as e:
        logger.error(f"Readiness check failed: {e}")
        return {
            "status": "not_ready",
            "reason": str(e),
            "timestamp": agent_registry._get_current_timestamp()
        }

@app.get("/health/live")
async def liveness_check():
    """
    Kubernetes liveness probe endpoint.
    
    Returns 200 if the system is alive and running,
    503 if the system should be restarted.
    """
    try:
        # Basic liveness check - system is alive if it can respond
        return {
            "status": "alive",
            "timestamp": agent_registry._get_current_timestamp(),
            "uptime": agent_registry._get_system_uptime()
        }
        
    except Exception as e:
        logger.error(f"Liveness check failed: {e}")
        return {
            "status": "dead",
            "reason": str(e),
            "timestamp": agent_registry._get_current_timestamp()
        }

# ============================================================================
# RATE LIMITING ENDPOINTS
# ============================================================================

@app.get("/rate-limits/{agent_id}")
async def get_agent_rate_limits(agent_id: str):
    """
    Get current rate limit status for a specific agent.
    
    Returns current rate limit usage and remaining capacity.
    """
    try:
        # Get agent from registry
        agent_route = get_agent_route(agent_id)
        agent = agent_registry.get_agent(agent_route)
        if not agent:
            raise HTTPException(status_code=404, detail="Agent not found")
        
        if not agent.config.rate_limit_config:
            return {
                "agent_id": agent_id,
                "rate_limiting": "disabled",
                "message": "Rate limiting not configured for this agent"
            }
        
        # Get rate limit status for different limit types
        status = {
            "agent_id": agent_id,
            "rate_limiting": "enabled",
            "config": {
                "requests_per_minute": agent.config.rate_limit_config.requests_per_minute,
                "requests_per_hour": agent.config.rate_limit_config.requests_per_hour,
                "requests_per_day": agent.config.rate_limit_config.requests_per_day,
                "burst_limit": agent.config.rate_limit_config.burst_limit
            },
            "limits": {}
        }
        
        # Get status for different limit types
        for limit_type in [RateLimitType.USER, RateLimitType.IP, RateLimitType.AGENT]:
            try:
                limit_status = await rate_limiter.get_rate_limit_status(
                    limit_type,
                    agent_id if limit_type == RateLimitType.AGENT else "example",
                    agent.config.rate_limit_config
                )
                status["limits"][limit_type.value] = limit_status
            except Exception as e:
                status["limits"][limit_type.value] = {"error": str(e)}
        
        return status
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Rate limit status check failed for {agent_id}: {e}")
        return {
            "agent_id": agent_id,
            "error": str(e),
            "timestamp": agent_registry._get_current_timestamp()
        }

@app.get("/rate-limits")
async def get_all_rate_limits():
    """
    Get rate limit status for all agents.
    
    Returns comprehensive rate limit information for all configured agents.
    """
    try:
        agents_status = {}
        
        for route, config in agent_registry.configs.items():
            agent_id = get_agent_id_from_route(route)
            
            if not config.rate_limit_config:
                agents_status[agent_id] = {
                    "rate_limiting": "disabled",
                    "message": "Rate limiting not configured"
                }
                continue
            
            try:
                # Get agent-specific rate limit status
                agent_status = await rate_limiter.get_rate_limit_status(
                    RateLimitType.AGENT,
                    agent_id,
                    config.rate_limit_config
                )
                
                agents_status[agent_id] = {
                    "rate_limiting": "enabled",
                    "config": {
                        "requests_per_minute": config.rate_limit_config.requests_per_minute,
                        "requests_per_hour": config.rate_limit_config.requests_per_hour,
                        "requests_per_day": config.rate_limit_config.requests_per_day,
                        "burst_limit": config.rate_limit_config.burst_limit
                    },
                    "current_usage": agent_status
                }
            except Exception as e:
                agents_status[agent_id] = {
                    "rate_limiting": "error",
                    "error": str(e)
                }
        
        return {
            "agents": agents_status,
            "total_agents": len(agents_status),
            "timestamp": agent_registry._get_current_timestamp()
        }
        
    except Exception as e:
        logger.error(f"Rate limits status check failed: {e}")
        return {
            "error": str(e),
            "timestamp": agent_registry._get_current_timestamp()
        }

# ============================================================================
# OAUTH 2.0 AUTHENTICATION ENDPOINTS - REMOVED (Using Clerk Only)
# ============================================================================

# REMOVED: OAuth endpoints - using Clerk authentication only
# @app.post("/oauth/authorize")
# async def authorize(
    response_type: str,
    client_id: str,
    redirect_uri: str,
    scope: str = "read",
    state: str = None
):
    """
    OAuth 2.0 Authorization Endpoint
    
    Handles the authorization code flow for OAuth 2.0.
    In a real implementation, this would redirect to a login page.
    """
    try:
        # Validate client
        client = oauth_provider.validate_client(client_id)
        if not client:
            raise HTTPException(status_code=400, detail="Invalid client_id")
        
        # Validate redirect URI
        if redirect_uri not in client.redirect_uris:
            raise HTTPException(status_code=400, detail="Invalid redirect_uri")
        
        # For demo purposes, we'll return a mock authorization code
        # In a real implementation, this would redirect to a login page
        if response_type == "code":
            # Mock user authentication - in real app, this would be handled by login form
            user_id = "admin"  # This would come from the login form
            
            auth_code = oauth_provider.generate_authorization_code(
                client_id=client_id,
                user_id=user_id,
                redirect_uri=redirect_uri,
                scope=scope
            )
            
            return {
                "authorization_code": auth_code,
                "state": state,
                "redirect_uri": redirect_uri
            }
        else:
            raise HTTPException(status_code=400, detail="Unsupported response_type")
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Authorization failed: {e}")
        raise HTTPException(status_code=500, detail="Authorization failed")

# @app.post("/oauth/token")
# async def token(
    grant_type: str = Form(...),
    client_id: str = Form(...),
    client_secret: str = Form(None),
    code: str = Form(None),
    redirect_uri: str = Form(None),
    refresh_token: str = Form(None),
    username: str = Form(None),
    password: str = Form(None),
    scope: str = Form("read"),
    org_id: str = Form(None),
    org_name: str = Form(None),
    org_role: str = Form(None)
):
    """
    OAuth 2.0 Token Endpoint
    
    Issues access and refresh tokens based on the grant type.
    """
    try:
        # Validate client
        client = oauth_provider.validate_client(client_id, client_secret)
        if not client:
            raise HTTPException(status_code=401, detail="Invalid client credentials")
        
        if grant_type == GrantType.AUTHORIZATION_CODE.value:
            # Authorization Code Grant
            if not code or not redirect_uri:
                raise HTTPException(status_code=400, detail="Missing code or redirect_uri")
            
            auth_data = oauth_provider.exchange_authorization_code(code, client_id, redirect_uri)
            if not auth_data:
                raise HTTPException(status_code=400, detail="Invalid authorization code")
            
            tokens = oauth_provider.generate_tokens(
                user_id=auth_data["user_id"],
                client_id=client_id,
                scope=auth_data["scope"]
            )
            
        elif grant_type == GrantType.CLIENT_CREDENTIALS.value:
            # Client Credentials Grant
            tokens = oauth_provider.generate_tokens(
                user_id=client_id,  # Use client_id as user_id for client_credentials
                client_id=client_id,
                scope=scope,
                org_id=org_id,
                org_name=org_name,
                org_role=org_role
            )
            
        elif grant_type == GrantType.REFRESH_TOKEN.value:
            # Refresh Token Grant
            if not refresh_token:
                raise HTTPException(status_code=400, detail="Missing refresh_token")
            
            tokens = oauth_provider.refresh_token(refresh_token)
            if not tokens:
                raise HTTPException(status_code=400, detail="Invalid refresh token")
                
        elif grant_type == GrantType.PASSWORD.value:
            # Password Grant (Resource Owner Password Credentials)
            if not username or not password:
                raise HTTPException(status_code=400, detail="Missing username or password")
            
            user = oauth_provider.authenticate_user(username, password)
            if not user:
                raise HTTPException(status_code=401, detail="Invalid credentials")
            
            tokens = oauth_provider.generate_tokens(
                user_id=user.user_id,
                client_id=client_id,
                scope=scope
            )
            
        else:
            raise HTTPException(status_code=400, detail="Unsupported grant_type")
        
        return {
            "access_token": tokens.access_token,
            "refresh_token": tokens.refresh_token,
            "token_type": tokens.token_type,
            "expires_in": tokens.expires_in,
            "scope": tokens.scope
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Token generation failed: {e}")
        raise HTTPException(status_code=500, detail="Token generation failed")

# @app.post("/oauth/revoke")
# async def revoke_token(token: str = Form(...)):
    """
    OAuth 2.0 Token Revocation Endpoint
    
    Revokes an access or refresh token.
    """
    try:
        success = oauth_provider.revoke_token(token)
        if success:
            return {"message": "Token revoked successfully"}
        else:
            return {"message": "Token not found or already revoked"}
            
    except Exception as e:
        logger.error(f"Token revocation failed: {e}")
        raise HTTPException(status_code=500, detail="Token revocation failed")

# @app.get("/oauth/userinfo")
# async def userinfo(authorization: str = None):
    """
    OAuth 2.0 UserInfo Endpoint
    
    Returns information about the authenticated user.
    """
    try:
        if not authorization or not authorization.startswith("Bearer "):
            raise HTTPException(status_code=401, detail="Missing or invalid authorization header")
        
        token = authorization.split(" ")[1]
        payload = oauth_provider.validate_token(token)
        if not payload:
            raise HTTPException(status_code=401, detail="Invalid token")
        
        user_id = payload.get("sub")
        if not user_id:
            raise HTTPException(status_code=401, detail="Invalid token payload")
        
        user = oauth_provider.get_user(user_id)
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        
        return {
            "sub": user.user_id,
            "username": user.username,
            "email": user.email,
            "roles": [role.value for role in user.roles],
            "is_active": user.is_active,
            "created_at": user.created_at.isoformat() if user.created_at else None,
            "last_login": user.last_login.isoformat() if user.last_login else None
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"UserInfo retrieval failed: {e}")
        raise HTTPException(status_code=500, detail="UserInfo retrieval failed")

# @app.get("/oauth/clients")
# async def list_clients():
    """
    List OAuth 2.0 clients (for admin purposes)
    """
    try:
        clients = []
        for client_id, client in oauth_provider.clients.items():
            clients.append({
                "client_id": client_id,
                "name": client.name,
                "redirect_uris": client.redirect_uris,
                "grant_types": [gt.value for gt in client.grant_types],
                "scopes": client.scopes,
                "is_confidential": client.is_confidential,
                "is_active": client.is_active,
                "created_at": client.created_at.isoformat() if client.created_at else None
            })
        
        return {
            "clients": clients,
            "total": len(clients)
        }
        
    except Exception as e:
        logger.error(f"Client listing failed: {e}")
        raise HTTPException(status_code=500, detail="Client listing failed")

# ============================================================================
# DISCOVERY ENDPOINTS (AG-UI Protocol Compliance)
# ============================================================================

@app.get("/.well-known/{agent_id}/agent.json")
async def get_agent_metadata(agent_id: str):
    """
    Provide agent metadata for discovery following AG-UI standards.
    
    This endpoint allows clients to discover agent capabilities, endpoints,
    and supported events dynamically.
    """
    
    # Get agent from registry
    agent_route = get_agent_route(agent_id)
    agent = agent_registry.get_agent(agent_route)
    if not agent:
        raise HTTPException(status_code=404, detail="Agent not found")
    
    config = agent_registry.configs.get(agent_route)
    
    # Get dynamic metadata from the agent
    dynamic_metadata = agent.get_dynamic_metadata()
    
    # Build base metadata
    metadata = {
        "agentId": agent_id,
        "name": config.name,
        "description": config.description,
        "version": config.version,
        "agentType": config.agent_type.value,
        "protocol": "AG-UI",
        "protocolVersion": "1.0.0",
        "lastUpdated": dynamic_metadata["last_updated"],
        "status": dynamic_metadata["status"]
    }
    
    # Add dynamic capabilities
    metadata["capabilities"] = dynamic_metadata["capabilities"]
    
    # Add supported events
    metadata["supportedEvents"] = dynamic_metadata["supported_events"]
    
    # Add tools if available
    if dynamic_metadata["tools"]:
        metadata["tools"] = dynamic_metadata["tools"]
    
    # Add models if available
    if dynamic_metadata["models"]:
        metadata["models"] = dynamic_metadata["models"]
    
    # Add endpoints
    metadata["endpoints"] = {
        "run": config.route,
        "stream": f"{config.route}/stream",
        "health": f"/agents/{agent_id}/health",
        "metadata": f"/.well-known/{agent_id}/agent.json"
    }
    
    # Add authentication info
    metadata["authentication"] = {
        "methods": ["header"] + (["oauth2"] if config.requires_auth else []),
        "required": config.requires_auth,
        "headers": ["X-User-ID", "X-Session-ID"] if config.requires_auth else []
    }
    
    # Add configuration
    metadata["configuration"] = {
        "timeout": config.timeout_seconds,
        "rateLimit": config.rate_limit,
        "defaultState": config.default_state is not None
    }
    
    # Add uptime if available
    if dynamic_metadata["uptime"]:
        metadata["uptime"] = dynamic_metadata["uptime"]
    
    # Add tags if available
    if config.tags:
        metadata["tags"] = config.tags
    
    return metadata

@app.get("/.well-known/agents")
async def list_all_agents():
    """
    List all available agents for discovery.
    
    This endpoint provides a registry of all available agents
    for dynamic discovery and integration.
    """
    
    agents = []
    for route, config in agent_registry.configs.items():
        agent_id = get_agent_id_from_route(route)
        agents.append({
            "agentId": agent_id,
            "name": config.name,
            "description": config.description,
            "route": route,
            "agentType": config.agent_type.value,
            "requiresAuth": config.requires_auth
        })
    
    return {
        "agents": agents,
        "total": len(agents),
        "protocol": "AG-UI",
        "version": "2.0.0"
    }


# ============================================================================
# AGENT SETUP
# ============================================================================

def setup_agents():
    """Setup all agents using the base agent system"""
    
    # Stock Analysis Agent
    stock_config = create_stock_agent_config(stock_analysis_workflow)
    agent_registry.register_agent(stock_config, StockAnalysisAgentHandler)
    
    # Ringi System Agent
    ringi_config = create_ringi_agent_config(ringi_workflow)
    agent_registry.register_agent(ringi_config, RingiAgentHandler)
    
    # Generic Agent
    generic_config = create_generic_agent_config(generic_agent_workflow)
    agent_registry.register_agent(generic_config, GenericAgentHandler)
    
    # BPP Agent (using generic handler for now)
    bpp_config = AgentConfig(
        name="BPP Assistant Agent",
        description="Business Process Platform AI Assistant",
        agent_type=AgentType.CUSTOM,
        route=get_agent_route("bpp-assistant"),
        workflow=bpp_assistant_workflow,
        requires_auth=False,
        timeout_seconds=180,
        version="2.1.0",
        capabilities=[
            "business-process-automation",
            "workflow-management",
            "data-integration",
            "process-optimization",
            "compliance-tracking",
            "reporting"
        ],
        supported_events=[
            "RUN_STARTED",
            "TEXT_MESSAGE_START",
            "TEXT_MESSAGE_CONTENT",
            "TEXT_MESSAGE_END",
            "TOOL_CALL_START",
            "TOOL_CALL_END",
            "STATE_DELTA",
            "STATE_SNAPSHOT",
            "RUN_FINISHED"
        ],
        tools=[
            {
                "name": "process_analyzer",
                "description": "Analyze business processes and workflows",
                "type": "function",
                "parameters": {
                    "process_id": {"type": "string", "description": "Process identifier"},
                    "analysis_type": {"type": "string", "description": "Type of analysis"}
                }
            },
            {
                "name": "workflow_optimizer",
                "description": "Optimize business workflows",
                "type": "function",
                "parameters": {
                    "workflow_data": {"type": "object", "description": "Workflow data"},
                    "optimization_goals": {"type": "array", "description": "Optimization objectives"}
                }
            }
        ],
        models=[
            {"name": "gpt-4o", "provider": "openai", "type": "chat", "purpose": "business_analysis"},
            {"name": "claude-3-sonnet", "provider": "anthropic", "type": "chat", "purpose": "process_optimization"}
        ],
        tags=["bpp", "business-process", "automation", "workflow", "enterprise"],
        rate_limit_config=RateLimitConfig(
            requests_per_minute=40,  # Medium limit for business processes
            requests_per_hour=600,
            requests_per_day=5000,
            burst_limit=8,
            enabled=True
        )
    )
    agent_registry.register_agent(bpp_config, GenericAgentHandler)
    
    logger.info(f"🚀 Setup complete! Registered {len(agent_registry.get_all_routes())} agents")


def main():
    """Run the uvicorn server"""
    # Setup all agents
    setup_agents()
    
    # Setup FastAPI routes for all agents
    agent_registry.setup_fastapi_routes(app)
    
    # Log all available routes
    routes = agent_registry.get_all_routes()
    logger.info(f"📡 Available agent routes: {routes}")
    
    # Check what routes were actually created
    app_routes = [route.path for route in app.routes if hasattr(route, 'path')]
    logger.info(f"🔗 FastAPI routes created: {app_routes}")
    
    # Check OpenAPI schema
    openapi = app.openapi()
    paths = list(openapi.get('paths', {}).keys())
    logger.info(f"📋 OpenAPI paths: {paths}")
    
    if not paths:
        logger.error("❌ No routes found in OpenAPI schema! Server may not work properly.")
    
    logger.info(f"🚀 Starting server on {config.HOST}:{config.PORT}")
    
    uvicorn.run(
        app,  # Pass app directly instead of string
        host=config.HOST,
        port=config.PORT,
        reload=config.DEBUG,
        log_level="info" if config.DEBUG else "warning",
    )


if __name__ == "__main__":
    main()
